# Abstract
This section gives a concise overview of the repository: a small example showing how to expose Rust code via a C ABI and consume it from Java 22+ (Java FFM API) using jextract-generated bindings.

# Usage
This project contains two main components:

- `rust-api` — a Rust workspace that builds a C-compatible dynamic library (`libfunctions_api.so`) and emits a C header (`include/functions.h`).
- `java-client` — a Java 25 Maven project that uses jextract-generated bindings to call the Rust library via the Java FFM API.

Quick usage summary:

1. Build the Rust library:

```bash
cd rust-api && cargo build
```

This produces `target/debug/libfunctions_api.so` and the header `rust-api/include/functions.h` (the header is generated by `cbindgen` during the `functions-api` build script).

2. Generate Java bindings (uses jextract):

```bash
./scripts/download_jextract.sh && ./scripts/generate_java_bindings.sh
```

This executes `jextract` and writes Java bindings into `java-client/src/main/java/de/marcoedenhofer/javarustffi/generated/bindings`.

3. Make the dynamic library available system-wide (Linux example):

```bash
sudo cp rust-api/target/debug/libfunctions_api.so /usr/local/lib/ && sudo ldconfig
```

4. Run the Java client (IDE or Maven):

- From an IDE: run `de.marcoedenhofer.javarustffi.Application#main`.
- From the command line (build and run):

```bash
cd java-client && mvn -DskipTests package && java -cp target/java-client-1.0.0-SNAPSHOT.jar de.marcoedenhofer.javarustffi.Application
```

> [!NOTE]
> The Java client expects the shared library to be installed in a location resolvable by the system linker (for Linux `/usr/local/lib` is common). If the JVM cannot locate the library, ensure the file is copied and the linker cache updated (`ldconfig`).

# Development
This section describes how to set up a development environment, build, test, and contribute.

## Setup
Required tools:

- Rust toolchain (`cargo`) — to build the Rust workspace.
- `cbindgen` (used as a build-dependency) — invoked by the `functions-api` build script to create `include/functions.h`.
- JDK 25+ (OpenJDK 25 recommended) — required for `jextract` and to compile the Java client.
- Maven — to build the Java client and run profiles.
- `wget`, `tar` — used by the provided script to download and extract `jextract`.

Platform notes:
- The instructions and scripts target Linux. Paths and linker steps may differ on macOS/Windows.

## Build
1. Build the Rust workspace (creates the dynamic library and header):

```bash
cd rust-api && cargo build
```

- Outputs: `target/debug/libfunctions_api.so` and `rust-api/include/functions.h`.

2. Generate Java bindings with jextract (scripts provided):

```bash
./scripts/download_jextract.sh && ./scripts/generate_java_bindings.sh
```

Or enable the Maven profile which runs the scripts during `generate-sources`:

```bash
mvn -Pgenerate-bindings generate-sources
```

3. Build the Java client:

```bash
cd java-client && mvn -DskipTests package
```

4. (Optional) Build a GraalVM native image of the Java client:

```bash
cd java-client && mvn -Pnative -DskipTests package
```

## Test
- Java unit tests use JUnit Jupiter. Run them with:

```bash
cd java-client && mvn test
```

- The Rust project in this example does not include automated tests, but you can run `cargo test` from `rust-api` when tests are added.

## Contributing
### Branching Strategy
A recommended approach is GitHub Flow: create short-lived feature branches and open pull requests into `main` for review.

### Release Strategy
Tag release commits using semantic versioning (e.g. `v1.2.3`). Releases may consist of a Rust `cdylib` artifact and a packaged Java client (Maven artifact or native image). Create a release tag and attach build artifacts as necessary.

### Other conventions
- Use semantic versioning for tags (`vMAJOR.MINOR.PATCH`).
- Prefer descriptive commit messages and small, focused PRs.
- When adding or changing public APIs, document compatibility and migration notes in the PR.

---
> Documentation generated at: 05.12.2025

